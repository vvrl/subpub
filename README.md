#subpub-vk

Для копирования репозитория применить git clone
```
git clone https://github.com/vvrl/subpub-vk.git
```

# Библиотека subpub

Библиотека была создана по имеющимся интерфейсам. Были созданы структуры для имплементации интерфейсов и дополнительно создана стурктура subscriber для удобной работы.

Структура subPub хранит map, где ключом является тема публикаций (subject), а значением другая map с подписчиками и в качестве значения пустая структура. Нам не важно значение, поэтому используется пустая структура, которая не занимает памяти. Использовать внутреннюю map было решено из-за уникальности ключа: подписчик не сможет подписаться несколько раз на один и тот же topic.

Буферизированый канал используется для того, чтобы не тормозить другие обработчики, если происходит какое-то зависание.

Мьютексы нужны для защиты данных от гонки записи. RWMutex используется потому что у нас много читателей и мало писателей, поэтому чтобы не тормозить всю программу при записи, используется блокировка только на запись, но читать другие горутины могут.

Тестирование проводилось только библиотеки subpub на основе black box и white box подходах. Основные операции (Subscribe(), Publish(), Close()) протестированы как API, не имея доступа к внутренним методам и структурам. Возвращаемые типы функций NewSubPub и Subscribe были протестированы "заглядывая внутрь" программы, обращаясь к неэкспортируемым типам данных.

Для визуализации покрытия кода тестами (последняя версия покрытия уже в репозитории):
```
go test -html=coverage.out
```

просто для запуска тестов:
```
go test ./subpub
```

для запуска тестов с логами:
```
go test -v ./subpub
```


# gRPC-сервер

Чтобы передавать сообщения подписываемся на поток (stream) и постоянно получаем от сервера сообщения, не опрашивая сервер. т.е это push-процесс (сервер толкает сообщения клиенту)

Для просмотра примера работы программы использовать go run:
```
go run ./cmd/main.go
```
Для остановки работы сервера был использован подход graceful shutdown: программа ждет сигнала из ОС, например Ctrl+C, спокойно завершает все свои процессы и останавливает работу
```
stop := make(chan os.Signal, 1)
signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
<-stop

logger.Info("Shutting down server...")

ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()

grpcServer.GracefulStop() // остановка сервера

if err := sp.Close(ctx); err != nil {
	logger.Errorf("Error closing subpub: %v", err)
}

logger.Info("Server stopped gracefully")
```
